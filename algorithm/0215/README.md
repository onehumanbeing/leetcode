因为这道题属于分治的范畴，故不使用排序的方法解决

这种解法是由快速排序发展起来的。 

快速排序中，每一次迭代，我们需要选取一个关键元素pivot，然后将数组分割成三个部分：

```
小于关键元素pivot的元素
等于关键元素pivot的元素
大于关键元素pivot的元素
```

现在，以[3,2,1,5,4,6]这个数组为例来分析。

假定每次选取最左端的元素作为关键的元素pivot，这种情况下，是3，然后我们使用3作为pivot将数组分成上面指定的3个部分，最后结果是[1,2,3,5,4,6]。现在3是第3个元素并且我们知道它也是第3小的元素。

由于上面的分割是将比pivot小的元素放在了pivot的左边，所以pivot当pivot在第k-1位置是是第k小的元素。由于这道题目需要寻找第k大的元素，我们可以修改一下分割过程将比pivot大的元素放在k的左边。这样，分割完成后数组变成了[5,6,4,3,1,2]，现在3是第4大的元素，如果我们需要寻找第2大的元素，我们知道它是在3左边，如果我们需要第5大的元素，我们知道它是在3右边。

现在简单写出算法的流程：

初始化left为0，right为nums.size()-1
分割数组，如果pivot在第k-1位，返回pivot
如果pivot在k-1右边，更新right为pivot的位置值
否则更新left为pivot的位置值。
重复2的步骤